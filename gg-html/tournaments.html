<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

<!-- СТИЛІ -->
<style>
  :root {
    --main-bg-color: #2C6DA3;   /* синій за замовчуванням */
    --hover-bg-color: #24598a; /* синій hover за замовчуванням */
  }

  body {
    font-family: 'Montserrat', sans-serif;
  }
  .tab-container {
    display: flex;
    gap: 0px;
    padding: 10px 0px;
    flex-wrap: wrap;
  }

  .tab {
    padding: 6px 12px;
    font-size: 15px;
    font-weight: 600;
    color: #333333;
    background-color: transparent;
    border-radius: 0px;
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
  }

  .tab.active,
  .tab:hover { 
    background-color: var(--main-bg-color);
    color: white;
  }

  .group-section {
    margin: 5px 0;
    padding: 0 0px;
  }

  .group-title {
    font-size: 14px;
    font-weight: 700;
    margin-bottom: 3px;
    color: #222;
  }

  .overview-section-title {
    font-size: 17px;
    font-weight: 700;
    margin-bottom: 3px;
    color: #222;
  }

  .overview-about-text {
    font-size: 14px;
    color: #333;
  }

  .group-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 16px;
    border-radius: 2px;
    box-shadow: 1.4px 1.4px 2px #b2b2b2;
    overflow: hidden;
  }

  .group-table th {
    background-color: var(--main-bg-color);
    color: white;
    font-weight: 600;
    padding: 6px;
    font-size: 15px;
    text-align: center;
    width: auto;
    min-width: 40px;
  }

  .group-table td {
    padding: 6px;
    font-size: 15px;
    line-height: 17px;
    border-top: 1px solid #ccc;
    text-align: center;
  }

  .group-table tr:nth-child(n+2) {
    background-color: white;
  }

  .group-table td a {
    color: #333333;
    text-decoration: none;
    word-break: break-word;
  }

  .group-table td a:hover {
    color: #0277BD;
  }

  .match-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 5px;
    border-radius: 2px;
    box-shadow: 1.4px 1.4px 2px #b2b2b2;
    overflow: hidden;
  }

  .match-table th {
    background-color: #e0f0ff;
    padding: 6px;
    text-align: left;
    font-size: 15px;
  }

  .match-table td:not(.lineup-cell) {
    background-color: white;
    padding: 6px;
    font-size: 15px;
    line-height: 17px;
    border-top: 1px solid #ccc;
  }

  .match-table td.lineup-cell {
    padding: 0;
  }
  .match-table td.date-cell {
    font-size: 13px;
    text-align: left;
    line-height: 15px;
  }
  .match-table td.player-cell {
    text-align: center;
  }
  .match-table td.score-cell {
    text-align: center;
    font-weight: 600;
    white-space: nowrap;
  }

  .match-table .score-cell .duel-score {
    font-weight: 600;
  }

  .match-table .score-cell .game-score {
    font-weight: normal;
    font-size: 13px;
  }

  .match-table .score-cell .score-line {
    display: block;
    line-height: 17px;
  }

  .match-table td a {
    color: #333333;
    text-decoration: none;
    word-break: break-word;
  }

  .match-table td a:hover {
    color: #0277BD;
  }

  /* Match Icon Wrapper and Icon */
  .match-icon-wrapper {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border: 1px solid #ccc;
    border-radius: 2px;
    width: 22px;
    height: 22px;
    box-sizing: border-box;
  }
  .match-icon-wrapper i {
    font-size: 14px;
    color: #444;
    width: 14px;
    height: 14px;
    margin: 0;
    padding: 0;
    position: static;
    line-height: 1;
  }

  .lineup__overview {
    padding: 0 10px;
    line-height: 18px;
  }

  @media (max-width: 600px) {
    .lineup__overview {
      font-size: 14px;
      line-height: 18px;
    }
  }

  .lineup {
    height: 0;
    overflow: hidden;
    font-size: 14px;
    transition: height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
    background-color: #f5f5f5;
  }

  .accordion-toggle {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: var(--main-bg-color);
    color: white;
    font-weight: 400;
    font-size: 15px;
    padding: 4px 10px;
    cursor: pointer;
    transition: background-color 0.2s ease;
    border-radius: 2px;
    box-shadow: 1.4px 1.4px 2px #b2b2b2;
  }

  .accordion-toggle:hover {
    background-color: var(--hover-bg-color);
  }

  .accordion-toggle .chevron {
    display: flex;
    align-items: center;
  }

  .accordion-toggle .chevron i {
    transition: transform 0.3s ease;
  }

  .accordion-toggle.open .chevron i {
    transform: rotate(180deg);
  }

  .accordion-content {
    overflow: hidden;
    transition: max-height 0.3s ease;
    padding: 0 2px;
  }

  #tab-playoff-content {
    display: block;
    overflow-x: auto;
    overflow-y: visible;
    height: auto !important;
    background-color: #f5f5f5;
  }
  #playoff-bracket {
    display: flex;
    align-items: flex-start;
    /* The scroll is now handled by .playoff-scroll-wrapper */
    width: 100%;
    position: relative;
    flex-wrap: nowrap;
    flex: 1 0 auto;
  }

  .playoff-scroll-wrapper {
    overflow-x: auto;
    overflow-y: hidden;
    width: 100%;
    margin-bottom: 16px;
  }
  .playoff-scroll-wrapper > div {
    min-width: max-content;
  }
  .round-label {
    font-weight: 600;
    font-size: 14px;
    margin-bottom: 10px;
  }
  .match-box {
    background-color: white;
    border: 1px solid #aaa;
    border-radius: 2px;
    font-size: 15px;
    line-height: 18px;
    margin-bottom: 20px;
    /*box-shadow: 1px 1px 2px #b2b2b2;*/
    box-sizing: border-box;
  }
  .match-box div {
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: 50%;
    gap: 6px;
  }
  .player-logo {
    height: 18px;
    width: 18px;
    border: 0.5px solid #444;
    object-fit: contain;
    margin-right: 0px;
    border-radius: 2px;
  }
   .team-logo {
    height: 20px;
    width: 20px;
    object-fit: contain;
    margin-right: 0px;
    border-radius: 2px;
  }
  .match-box a {
    color: #333333;
    text-decoration: none;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .match-box a:hover {
    color: #0277BD;
  }

  .match-row-winner {
    /* background-color: #fff; */
    font-weight: 550;
    padding: 0 7px;  
  }

  .match-row-loser {
    /* background-color: #fff; */
    padding: 0 7px; 
  }

  .highlight-player {
    background-color: #eeeeee !important;
  }
  .highlight-text {
    font-weight: 600;
  }

  /* Responsive: Limit width of time cell on mobile */
  @media (max-width: 768px) {
    .match-table td.date-cell {
      max-width: 60px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  }
</style>

<!-- HTML -->
<div id="tournament-title" style="font-size:18px; font-weight:700; line-height:20px; padding:0 0 10px;"></div>
<div class="tab-container" id="tab-container"></div>
<div id="tab-overview-content" style="display:none;"></div>
<div id="tab-matches-content" style="display:none;"></div>
<div id="tab-stage1-content" style="display:none;"></div>
<div id="tab-stage2-content" style="display:none;"></div>
<div id="tab-teams-content" style="display:none;"></div>
<div id="tab-rules-content" style="display:none;"></div>

<!-- СКРИПТ -->
<script>
  
  // --- TOURNAMENT ID ---
  // Determine currentTournamentId either from test default or from the page URL
  const useTestData = window.location.hostname !== "carcassonne.gg";
  let currentTournamentId = useTestData
    ? "Asian-Cup-2025"
    //? "TECS-2025"
    //? "TW-2024-CCLQ"
    : window.location.pathname.split('/').filter(Boolean).pop();
  let currentTournament = null;

  // --- Dynamic theme colors ---
  if (currentTournamentId === "Asian-Cup-2025") {
    document.documentElement.style.setProperty('--main-bg-color', '#d85c5c');
    document.documentElement.style.setProperty('--hover-bg-color', '#c64a4b');
  }

  let matches = [];
  let duels = [];
  let standings = [];
  let players = [];
  let tournament_players = [];
  let countries = [];
  let teams = [];
  let streams = [];

  function fetchTournamentsAndInit() {
    // --- FETCH TOURNAMENT DATA ---
    // Load all tournament-related data from one unified API endpoint
    fetch("https://api.carcassonne.com.ua/tournaments")
      .then(res => {
        if (!res.ok) throw new Error("Primary fetch failed");
        return res.json();
      })
      .catch(() => {
        console.warn("⚠️ Using fallback tournament data from GitHub.");
        return fetch("https://zaharik-ua.github.io/carcassonne-gg/fallback-data/tournaments.json")
          .then(res => res.json());
      })
      .then(data => {
        if (!data || !data.tournaments || !Array.isArray(data.tournaments)) {
          document.getElementById("tab-standing-content").textContent = "❌ Failed to load tournament data";
          return;
        }

        const allTournaments = data.tournaments;
        currentTournament = allTournaments.find(t => t.tournament_id === currentTournamentId);
        if (currentTournament) {
          document.getElementById("tournament-title").textContent = currentTournament.name;
        }

        // Збереження відповідних частин даних
        duels = data.duels || [];
        standings = data.standings || [];
        matches = data.matches || [];
        players = data.players || [];
        tournament_players = data.tournament_players || [];
        countries = data.countries || [];
        teams = data.teams || [];
        streams = data.streams || [];
        initAndRenderTournamentContent(currentTournament);
      });
  }

  function initAndRenderTournamentContent(currentTournament) {
    // --- INIT TOURNAMENT CONTENT ---
    // Dynamically create tabs and content containers based on tournament configuration
    const tabContainer = document.getElementById("tab-container");
    tabContainer.innerHTML = ""; // clear previous tabs

    document.getElementById("tab-overview-content").style.display = "block";
    document.getElementById("tab-matches-content").style.display = "none";
    document.getElementById("tab-stage1-content").style.display = "none";
    document.getElementById("tab-stage2-content").style.display = "none";
    document.getElementById("tab-rules-content").style.display = "none";

    // --- Collect tournament structure info ---
    const tournament_format = currentTournament.tournament_format || "";
    const stage1_format = currentTournament.stage1_format || "";
    const stage2_format = currentTournament.stage2_format || "";
    const stage1_groups = currentTournament.stage1_groups || null;
    const rules = currentTournament.rules || "";

    // --- Build tabs in fixed order: Overview, Stage 2 (if present), Stage 1, Matches, Teams (if present), Rules (if present) ---
    const tabDefs = [];
    tabDefs.push({ id: "overview", label: "Overview" });

    // Stage 2 tab (conditionally shown if tournament_format === "2 Stages")
    let stage2Tab = null;
    if (tournament_format === "2 Stages") {
      let stage2Label = "";
      if (stage2_format === "Single Elimination" || stage2_format === "Double Elimination") {
        stage2Label = "Playoffs";
      } else if (stage2_format === "Round-robin" || stage2_format === "Swiss") {
        stage2Label = "Final Stage";
      } else {
        stage2Label = "Stage 2";
      }
      stage2Tab = { id: "stage2", label: stage2Label };
      tabDefs.push(stage2Tab);
    }

    // Stage 1 tab (always shown)
    let stage1Label = "";
    if (tournament_format === "1 Stage") {
      if (stage1_format === "Round-robin" || stage1_format === "Swiss") {
        stage1Label = "Standings";
      } else if (stage1_format === "Single Elimination") {
        stage1Label = "Single Elimination Bracket";
      } else if (stage1_format === "Double Elimination") {
        stage1Label = "Double Elimination Bracket";
      } else {
        stage1Label = "Stage 1";
      }
    } else if (tournament_format === "2 Stages") {
      if (stage1_groups === "Groups") {
        stage1Label = "Groups Stage";
      } else if (stage1_groups === null && stage1_format === "Round-robin") {
        stage1Label = "Round-robin Stage";
      } else if (stage1_groups === null && stage1_format === "Swiss") {
        stage1Label = "Swiss Stage";
      } else {
        stage1Label = "Stage 1";
      }
    } else {
      stage1Label = "Stage 1";
    }
    let stage1Tab = { id: "stage1", label: stage1Label };
    tabDefs.push(stage1Tab);

    // Matches tab (always shown)
    tabDefs.push({ id: "matches", label: "Matches" });

    // Teams tab (conditionally shown if team tournament)
    let teamsTab = null;
    if (currentTournament.type === "TEAM") {
      teamsTab = { id: "teams", label: "Teams" };
      tabDefs.push(teamsTab);
    }

    // Rules tab (conditionally shown if rules exist)
    let rulesTab = null;
    if (rules && rules.trim() !== "") {
      rulesTab = { id: "rules", label: "Rules" };
      tabDefs.push(rulesTab);
    }

    // --- Render tabs ---
    tabDefs.forEach((tab, idx) => {
      const tabEl = document.createElement("div");
      tabEl.className = "tab" + (idx === 0 ? " active" : "");
      tabEl.dataset.tab = tab.id;
      tabEl.textContent = tab.label;
      tabContainer.appendChild(tabEl);
    });

    // --- CHECK URL PARAM FOR DEFAULT TAB ---
    const urlParams = new URLSearchParams(window.location.search);
    const requestedTab = urlParams.get("tab");
    const defaultTabId = tabDefs.find(t => t.id === requestedTab) ? requestedTab : tabDefs[0].id;

    // --- Tab click logic ---
    function showTab(tabId) {
      // Remove .active from all tabs, add to the selected tab
      tabContainer.querySelectorAll(".tab").forEach(tabEl => {
        tabEl.classList.toggle("active", tabEl.dataset.tab === tabId);
      });
      // Hide all content containers
      document.getElementById("tab-overview-content").style.display = "none";
      document.getElementById("tab-matches-content").style.display = "none";
      document.getElementById("tab-stage1-content").style.display = "none";
      document.getElementById("tab-stage2-content").style.display = "none";
      document.getElementById("tab-teams-content").style.display = "none";
      document.getElementById("tab-rules-content").style.display = "none";
      // Show the selected
      if (tabId === "overview") {
        document.getElementById("tab-overview-content").style.display = "block";
      } else if (tabId === "matches") {
        document.getElementById("tab-matches-content").style.display = "block";
      } else if (tabId === "stage1") {
        document.getElementById("tab-stage1-content").style.display = "block";
      } else if (tabId === "stage2") {
        document.getElementById("tab-stage2-content").style.display = "block";
      } else if (tabId === "teams") {
        document.getElementById("tab-teams-content").style.display = "block";
      } else if (tabId === "rules") {
        document.getElementById("tab-rules-content").style.display = "block";
      }
    }
    // Attach click listeners
    tabContainer.querySelectorAll(".tab").forEach(tabEl => {
      tabEl.addEventListener("click", () => {
        showTab(tabEl.dataset.tab);
      });
    });
    

    // --- Render content for each tab ---
    // Overview
    renderOverviewContent();
    // Matches
    renderMatchesData();

    // Stage 1 content
    const stage1Container = document.getElementById("tab-stage1-content");
    stage1Container.innerHTML = "";
    if (tournament_format === "1 Stage") {
      if (stage1_format === "Round-robin" || stage1_format === "Swiss") {
        renderStandingsData(
          standings.filter(s => s.tournament_id === currentTournamentId),
          stage1Container
        );
      } else if (stage1_format === "Single Elimination") {
        renderPlayoffData(
          currentTournament.type === "TEAM"
            ? matches.filter(d => d.tournament_id === currentTournamentId)
            : duels.filter(d => d.tournament_id === currentTournamentId),
          stage1Container,
          currentTournament.type
        );
      } else if (stage1_format === "Double Elimination") {
        stage1Container.textContent = "Double Elimination support coming soon.";
      } else {
        stage1Container.textContent = "Stage 1 info not available.";
      }
    } else if (tournament_format === "2 Stages") {
      if (stage1_groups === "Groups") {
        if (stage1_format === "Round-robin" || stage1_format === "Swiss") {
          renderStandingsData(
            standings.filter(s => s.tournament_id === currentTournamentId && (!s.stage || s.stage === "Stage 1")),
            stage1Container
          );
        } else if (stage1_format === "Single Elimination") {
          const grouped = {};
          (currentTournament.type === "TEAM"
            ? matches
            : duels
          )
            .filter(d => d.tournament_id === currentTournamentId && d.stage === "Groups" && d.round_order !== null && d.group)
            .forEach(d => {
              if (!grouped[d.group]) grouped[d.group] = [];
              grouped[d.group].push(d);
            });
          for (const [group, duelsInGroup] of Object.entries(grouped)) {
            const groupSection = document.createElement("div");
            groupSection.className = "group-section";

            const groupTitle = document.createElement("div");
            groupTitle.className = "group-title";
            groupTitle.textContent = `Group ${group}`;

            const groupBracketWrapper = document.createElement("div");
            groupBracketWrapper.className = "group-bracket";

            groupSection.appendChild(groupTitle);
            groupSection.appendChild(groupBracketWrapper);
            stage1Container.appendChild(groupSection);
            renderPlayoffData(
              duelsInGroup,
              groupBracketWrapper,
              currentTournament.type
            );
          }
        } else if (stage1_format === "Double Elimination") {
          stage1Container.textContent = "Double Elimination support coming soon.";
        } else {
          stage1Container.textContent = "Stage 1 info not available.";
        }
      } else if (stage1_groups === null && stage1_format === "Round-robin") {
        renderStandingsData(
          standings.filter(s => s.tournament_id === currentTournamentId && (!s.stage || s.stage === "Stage 1")),
          stage1Container
        );
      } else if (stage1_groups === null && stage1_format === "Swiss") {
        renderStandingsData(
          standings.filter(s => s.tournament_id === currentTournamentId && (!s.stage || s.stage === "Stage 1")),
          stage1Container
        );
      } else {
        stage1Container.textContent = "Stage 1 info not available.";
      }
    } else {
      stage1Container.textContent = "Stage 1 info not available.";
    }

    // Stage 2 content (if present)
    if (stage2Tab) {
      const stage2Container = document.getElementById("tab-stage2-content");
      stage2Container.innerHTML = "";
      if (stage2_format === "Single Elimination") {
        renderPlayoffData(
          currentTournament.type === "TEAM"
            ? matches.filter(d => d.tournament_id === currentTournamentId && d.stage === "Playoffs")
            : duels.filter(d => d.tournament_id === currentTournamentId && d.stage === "Playoffs"),
          stage2Container,
          currentTournament.type
        );
      } else if (stage2_format === "Double Elimination") {
        stage2Container.textContent = "Double Elimination support coming soon.";
      } else if (stage2_format === "Round-robin" || stage2_format === "Swiss") {
        renderStandingsData(
          standings.filter(s => s.tournament_id === currentTournamentId && s.stage === "Stage 2"),
          stage2Container
        );
      } else {
        stage2Container.textContent = "Stage 2 info not available.";
      }
    }
    
    // Rules content (if present)
    if (rulesTab) {
      const rulesContainer = document.getElementById("tab-rules-content");
      rulesContainer.innerHTML = "";
      rulesContainer.innerHTML = `<div style="font-size:14px;">${currentTournament.rules}</div>`;
    }

    // Teams content (if present)
    if (teamsTab) {
      const teamsContainer = document.getElementById("tab-teams-content");
      teamsContainer.innerHTML = "";

      const groupedPlayers = {};
      tournament_players
        .filter(p => p.tournament_id === currentTournamentId)
        .forEach(p => {
          if (!groupedPlayers[p.team]) groupedPlayers[p.team] = [];
          groupedPlayers[p.team].push(p);
        });

      const sortedTeams = Object.keys(groupedPlayers).sort();

      const wrapper = document.createElement("div");
      wrapper.style.display = "flex";
      wrapper.style.flexWrap = "wrap";
      wrapper.style.gap = "20px";
      wrapper.style.alignItems = "flex-start";

      sortedTeams.forEach(teamName => {
        const teamTable = document.createElement("table");
        teamTable.className = "group-table";
        teamTable.style.width = "300px";
        teamTable.style.tableLayout = "fixed";

        const logo = teams.find(t => t.team === teamName)?.logo;
        const headerRow = document.createElement("tr");
        headerRow.innerHTML = `
          <th colspan="2" style="text-align:left;">
            <div style="display: flex; align-items: center; gap: 8px;">
              ${logo ? `<img src="${logo}" alt="${teamName}" style="height: 20px;">` : ""}
              <span>${teamName}</span>
            </div>
          </th>
        `;
        teamTable.appendChild(headerRow);

        const sortedPlayers = groupedPlayers[teamName].sort((a, b) => a.player.localeCompare(b.player));

        sortedPlayers.forEach(playerEntry => {
          const player = players.find(p => p.player_id === playerEntry.player_id);
          const avatar = player?.avatar;
          const playerRow = document.createElement("tr");
          playerRow.innerHTML = `
            <td style="text-align:left;" colspan="2">
              <div style="display: flex; align-items: center; gap: 7px;">
                ${avatar ? `<img src="${avatar}" class="player-logo">` : ""}
                ${playerEntry.player ? `<a href="https://boardgamearena.com/player?id=${playerEntry.player_id}" target="_blank">${playerEntry.player}</a>` : ""}
                ${playerEntry.captain === "Captain" ? `<img src="https://carcassonne.gg/gallery/captain.png" alt="Captain" style="height: 16px;">` : ""}
              </div>
            </td>
          `;
          teamTable.appendChild(playerRow);
        });

        // Wrap the teamTable in a div to prevent height stretching
        const tableWrapper = document.createElement("div");
        tableWrapper.style.flex = "none";
        tableWrapper.appendChild(teamTable);
        wrapper.appendChild(tableWrapper);
      });

      teamsContainer.appendChild(wrapper);
    }
    // Show the first tab by default, or the requested one
    showTab(defaultTabId);
  }

  function renderOverviewContent() {
    const container = document.getElementById("tab-overview-content");
    container.innerHTML = '';

    if (currentTournament.final_ranking) {
      const section = document.createElement("div");
      section.className = "group-section";

      const title = document.createElement("div");
      title.className = "overview-section-title";
      title.textContent = "Final Ranking";
      section.appendChild(title);

      const table = document.createElement("table");
      // Apply special styling for Final Ranking table only
      table.className = "group-table";
      table.style.maxWidth = "400px";
      table.style.margin = "0 auto";

      table.innerHTML = `
        <tr>
          <th style="width:10%; min-width:40px;">Rank</th>
          <th style="width:90%; min-width:100px; text-align:left;">Player</th>
        </tr>
      `;

      const entries = currentTournament.final_ranking.split(';').map(entry => {
        const [order, player, icon] = entry.split(',');
        return { order: parseInt(order), player, icon };
      });

      entries.sort((a, b) => a.order - b.order).forEach(entry => {
        const row = document.createElement("tr");
        row.innerHTML = `
          <td style="text-align:center;">${entry.icon}</td>
          <td style="text-align:left;">${entry.player}</td>
        `;
        table.appendChild(row);
      });

      section.appendChild(table);
      container.appendChild(section);
    }

    if (currentTournament.about) {
      const section = document.createElement("div");
      section.className = "group-section";

      const title = document.createElement("div");
      title.className = "overview-section-title";
      title.textContent = "About";
      section.appendChild(title);

      const content = document.createElement("div");
      content.innerHTML = currentTournament.about;
      content.className = "overview-about-text";
      section.appendChild(content);
      container.appendChild(section);
    }
  }

function renderStandingsData(standings_list, containerOverride) {
  // --- RENDER STANDINGS ---
  // Build standings tables grouped by group, sorted and styled with logos
  const container = containerOverride || document.getElementById("tab-standing-content");
  container.innerHTML = '';
  const grouped = {};
  standings_list
    .filter(row => row.tournament_id === currentTournamentId && (
      (container.id === "tab-stage1-content" && (!row.stage || row.stage === "Stage 1")) ||
      (container.id === "tab-stage2-content" && row.stage === "Stage 2")
    ))
    .forEach(row => {
      if (!grouped[row.group]) grouped[row.group] = [];
      grouped[row.group].push(row);
    });
  // Determine if TEAM or not
  const isTeam = currentTournament && currentTournament.type === "TEAM";
  for (const [group, groupPlayers] of Object.entries(grouped)) {
    const section = document.createElement("div");
    section.className = "group-section";

    const title = document.createElement("div");
    title.className = "group-title";
    title.textContent = `Group ${group}`;
    section.appendChild(title);

    // Sort logic: for TEAM, sort by MW, then DW-DL, then GW-GL; else as before
    if (isTeam) {
      groupPlayers.sort((a, b) => {
        // MW
        const mwDiff = +b.matches_won - +a.matches_won;
        if (mwDiff !== 0) return mwDiff;
        // DW - DL
        const duelDiffA = (+a.duels_won || 0) - (+a.duels_lost || 0);
        const duelDiffB = (+b.duels_won || 0) - (+b.duels_lost || 0);
        const ddDiff = duelDiffB - duelDiffA;
        if (ddDiff !== 0) return ddDiff;
        // GW - GL
        const gameDiffA = (+a.games_won || 0) - (+a.games_lost || 0);
        const gameDiffB = (+b.games_won || 0) - (+b.games_lost || 0);
        const gdDiff = gameDiffB - gameDiffA;
        if (gdDiff !== 0) return gdDiff;
        // GW
        return (+b.games_won || 0) - (+a.games_won || 0);
      });
    } else {
      groupPlayers.sort((a, b) => {
        const mwDiff = +b.matches_won - +a.matches_won;
        if (mwDiff !== 0) return mwDiff;
        const mdDiff = +b.matches_difference - +a.matches_difference;
        if (mdDiff !== 0) return mdDiff;
        return +b.games_difference - +a.games_difference;
      });
    }

    const table = document.createElement("table");
    table.className = "group-table";

    if (isTeam) {
      // TEAM header
      table.style.tableLayout = "fixed";
      table.innerHTML = `
        <tr>
          <th style="width:5%; min-width:30px;"></th>
          <th style="width:45%; min-width:150px; text-align:left;">Team</th>
          <th style="width:10%; min-width:30px;">MP</th>
          <th style="width:10%; min-width:30px;">MW</th>
          <th style="width:10%; min-width:30px;">ML</th>
          <th style="width:10%; min-width:30px;">DW</th>
          <th style="width:10%; min-width:30px;">DL</th>
          <th style="width:10%; min-width:30px;">GW</th>
          <th style="width:10%; min-width:30px;">GL</th>
        </tr>
      `;
      groupPlayers.forEach((standing, index) => {
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${index + 1}</td>
          <td style="text-align:left;">
            <div style="display: flex; align-items: center; gap: 7px;">
              ${(() => {
                const found = teams.find(t => t.team === standing.team);
                return found && found.logo ? `<img src="${found.logo}" class="team-logo">` : '';
              })()}
              ${standing.team}
            </div>
          </td>
          <td>${standing.matches_played}</td>
          <td>${standing.matches_won}</td>
          <td>${standing.matches_lost}</td>
          <td>${standing.duels_won}</td>
          <td>${standing.duels_lost}</td>
          <td>${standing.games_won}</td>
          <td>${standing.games_lost}</td>
        `;
        table.appendChild(row);
      });
    } else {
      // PLAYER header
      table.innerHTML = `
        <tr>
          <th style="width:5%; min-width:30px;"></th>
          <th style="width:45%; min-width:150px; text-align:left;">Player</th>
          <th style="width:10%; min-width:30px;">MP</th>
          <th style="width:10%; min-width:30px;">MW</th>
          <th style="width:10%; min-width:30px;">ML</th>
          <th style="width:10%; min-width:30px;">GW</th>
          <th style="width:10%; min-width:30px;">GL</th>
        </tr>
      `;
      groupPlayers.forEach((p, index) => {
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${index + 1}</td>
          <td style="text-align:left;">
            <div style="display: flex; align-items: center; gap: 7px;">
              ${(() => {
                const found = players.find(pl => pl.player_id === p.player_id);
                return found && found.avatar ? `<img src="${found.avatar}" class="player-logo">` : '';
              })()}
              <a href="https://boardgamearena.com/player?id=${p.player_id}" target="_blank" style="display: inline-block; white-space: normal; word-break: break-word;">${p.player}</a>
            </div>
          </td>
          <td>${p.matches_played}</td>
          <td>${p.matches_won}</td>
          <td>${p.matches_lost}</td>
          <td>${p.games_won}</td>
          <td>${p.games_lost}</td>
        `;
        table.appendChild(row);
      });
    }

    section.appendChild(table);
    container.appendChild(section);
  }

  // Explanatory text under the table
  // For TEAM: full legend + rules; for COC: short legend; else: previous behavior
  let explanation = null;
  if (currentTournament && currentTournament.type === "TEAM") {
    explanation = document.createElement("div");
    explanation.style.fontSize = "13px";
    explanation.innerHTML = `
      <p>MP: Matches Played MW: Matches Won ML: Matches Lost DW: Duels Won DL: Duels Lost GW: Games Won GL: Games Lost</p>
      <p>The final positions in the group will be determined in the following order:<br>
        1. Number of MW<br>
        2. The difference between DW and DL<br>
        3. The difference between GW and GL<br>
        4. Number of GW<br>
        5. Tiebreakers 1–4, but applied only to confrontations between players with equal results<br>
        6. The difference in points scored in confrontations between players with equal results<br>
        7. Random draw
      </p>
    `;
    container.appendChild(explanation);
  } else if (currentTournament && currentTournament.type === "COC") {
    explanation = document.createElement("p");
    explanation.style.fontSize = "13px";
    explanation.innerHTML = `
      <p><span class="highlight-text">MP:</span> Matches Played <span class="highlight-text">MW:</span> Matches Won <span class="highlight-text">ML:</span> Matches Lost <span class="highlight-text">GW:</span> Games Won <span class="highlight-text">GL:</span> Games Lost</p>
      <p>The final positions in the group will be determined in the following order:<br>
      1. Number of MW<br>
      2. The difference between GW and GL<br>
      3. Number of GW<br>
      4. Tiebreakers 1–3, but applied only to confrontations between players with equal results<br>
      5. The difference in points scored in confrontations between players with equal results<br>
      6. Random draw</p>
    `;
    container.appendChild(explanation);
  } else {
    explanation = document.createElement("div");
    explanation.style.fontSize = "13px";
    explanation.innerHTML = '<span class="highlight-text">MP:</span> Matches Played <span class="highlight-text">MW:</span> Matches Won <span class="highlight-text">ML:</span> Matches Lost <span class="highlight-text">GW:</span> Games Won <span class="highlight-text">GL:</span> Games Lost<br><br>The final positions in the group will be determined in the following order:<br>1. Number of MW<br>2. The difference between GW and GL<br>3. Number of GW<br>4. Tiebreakers 1-3, but applied only to confrontations between players with equal results<br>5. The difference in points scored in confrontations between players with equal results<br>6. Random draw';
    container.appendChild(explanation);
  }
}

  function renderMatchesData() {
    // --- RENDER MATCHES ---
    // Group matches by round and build collapsible sections for each round
    const container = document.getElementById("tab-matches-content");
    container.innerHTML = '';

    const matchesToRender = currentTournament.type === "TEAM" ? matches : duels;

    const groupedByRound = {};
    matchesToRender
      .filter(match => match.tournament_id === currentTournamentId)
      .forEach(match => {
        if (!groupedByRound[match.round]) groupedByRound[match.round] = [];
        groupedByRound[match.round].push(match);
      });

    let openAccordion = null;

    for (const [round, roundMatches] of Object.entries(groupedByRound)) {
      const section = document.createElement("div");
      section.className = "group-section";

      const toggle = document.createElement("div");
      toggle.className = "accordion-toggle";
      toggle.innerHTML = '';
      const labelSpan = document.createElement("span");
      labelSpan.textContent = round;

      const chevronDiv = document.createElement("div");
      chevronDiv.className = "chevron";
      chevronDiv.innerHTML = '<i class="fas fa-chevron-down"></i>';

      toggle.appendChild(labelSpan);
      toggle.appendChild(chevronDiv);

      const content = document.createElement("div");
      content.className = "accordion-content";
      content.style.maxHeight = "0px";

      const table = document.createElement("table");
      table.className = "match-table";

      const isGroupStage = roundMatches[0]?.stage === "Groups" || roundMatches[0]?.stage === "Group";

      roundMatches.forEach(g => {
        const row = document.createElement("tr");

        if (currentTournament.type === "TEAM") {
          // --- TEAM LOGIC: render team name + logo ---
          // Find logos by team name (from teams array)
          const team1Logo = teams.find(t => t.team === g.team1)?.logo;
          const team2Logo = teams.find(t => t.team === g.team2)?.logo;

          const team1Content = team1Logo
            ? `<img src="${team1Logo}" alt="${g.team1}" style="height: 20px; vertical-align: middle; margin-right: 7px;">${g.team1}`
            : g.team1;
          const team2Content = team2Logo
            ? `${g.team2}<img src="${team2Logo}" alt="${g.team2}" style="height: 20px; vertical-align: middle; margin-left: 7px;">`
            : g.team2;

          const team1Cell = `<td class="player-cell" style="text-align:center;">
            <div style="display:flex; align-items:center; justify-content:center;">
              ${team1Content || ''}
            </div>
          </td>`;
          const team2Cell = `<td class="player-cell" style="text-align:center;">
            <div style="display:flex; align-items:center; justify-content:center;">
              ${team2Content || ''}
            </div>
          </td>`;

          // Score cell logic
          let scoreCellHtml = '';
          if (
            g.duels_won1 === null || g.duels_won2 === null ||
            g.games_won1 === null || g.games_won2 === null
          ) {
            scoreCellHtml = `<td class="score-cell"></td>`;
          } else {
            scoreCellHtml = `<td class="score-cell">
              <span class="duel-score score-line">${g.duels_won1} - ${g.duels_won2}</span>
              <span class="game-score score-line">(${g.games_won1} - ${g.games_won2})</span>
            </td>`;
          }

          row.innerHTML = `
            <td class="date-cell">${g.time || ''}</td>
            ${g.group ? `<td>${g.group}</td>` : ""}
            ${team1Cell}
            ${scoreCellHtml}
            ${team2Cell}
          `;

          // --- APPEND DUELS ICON CELL (ALWAYS APPEND CELL TO MAINTAIN ALIGNMENT) ---
          const iconCell = document.createElement("td");
          iconCell.style.textAlign = "right";
          iconCell.style.paddingRight = "8px";

          let lineupDiv = null;
          if (
            g.match_id &&
            duels.some(d => d.match_id === g.match_id)
          ) {
            const icon = document.createElement("i");
            icon.className = "fas fa-list";
            const iconWrapper = document.createElement("div");
            iconWrapper.className = "match-icon-wrapper";
            iconWrapper.style.backgroundColor = g.status === "DONE" ? "#d2f4d2" : "#f9db9e";
            iconWrapper.appendChild(icon);
            iconCell.appendChild(iconWrapper);

            // --- BEGIN: Insert lineup dropdown ---
            lineupDiv = document.createElement("div");
            lineupDiv.className = "lineup";

            const lineupContDiv = document.createElement("div");
            lineupContDiv.className = "lineup__overview";

            const relevantDuels = duels.filter(d => d.match_id === g.match_id);
            lineupContDiv.innerHTML = relevantDuels.map(duel => {
              const player1Avatar = players.find(p => p.player_id === duel.player1_id)?.avatar;
              const player2Avatar = players.find(p => p.player_id === duel.player2_id)?.avatar;
              const player1 = `<a href="https://boardgamearena.com/player?id=${duel.player1_id}" target="_blank" style="text-decoration: none; color: inherit;">
                ${player1Avatar ? `<img src="${player1Avatar}" class="player-logo" style="margin-right: 5px; height: 15px; width: 15px; vertical-align: middle;">` : ""}
                ${duel.player1}
              </a>`;
              const player2 = `<a href="https://boardgamearena.com/player?id=${duel.player2_id}" target="_blank" style="text-decoration: none; color: inherit;">
                ${duel.player2}
                ${player2Avatar ? `<img src="${player2Avatar}" class="player-logo" style="margin-left: 5px; height: 15px; width: 15px; vertical-align: middle;">` : ""}
              </a>`;
              const score = duel.score1 !== null && duel.score2 !== null ? `<strong>${duel.score1} - ${duel.score2}</strong>` : `<strong>vs</strong>`;
              return `<div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">${player1} ${score} ${player2}</div>`;
            }).join("");

            lineupDiv.appendChild(lineupContDiv);
            // --- END: Insert lineup dropdown ---
          }
          // Append the cell in all cases to maintain row alignment
          row.appendChild(iconCell);
          table.appendChild(row);
          if (lineupDiv) {
            const lineupRow = document.createElement("tr");
            const lineupCell = document.createElement("td");
            lineupCell.className = "lineup-cell";
            lineupCell.colSpan = row.children.length; // на всю ширину
            lineupCell.appendChild(lineupDiv);
            lineupRow.appendChild(lineupCell);
            table.appendChild(lineupRow);
          }
          // --- BEGIN: Add toggle functionality for lineupDiv when iconCell is clicked ---
          if (lineupDiv && iconCell) {
            iconCell.style.cursor = "pointer";
            iconCell.addEventListener("click", () => {
              // Use offsetHeight to determine expanded state for first click
              const isExpanded = lineupDiv.offsetHeight > 0;
              if (isExpanded) {
                lineupDiv.style.height = "0px";
                lineupDiv.style.opacity = "0";
                lineupDiv.style.padding = "0";
              } else {
                lineupDiv.style.height = lineupDiv.scrollHeight + "px";
                lineupDiv.style.opacity = "1";
                lineupDiv.style.padding = "10px 0";
              }
              // Update accordion-content maxHeight after transition
              const accordionContent = iconCell.closest(".accordion-content");
              if (accordionContent) {
                setTimeout(() => {
                  accordionContent.style.maxHeight = accordionContent.scrollHeight + "px";
                }, 310); // match transition duration
              }
            });
          }
          // --- END: Add toggle functionality ---
          return; // to avoid re-appending row later
        } else {
          // --- PLAYER LOGIC: render player name + avatar + link ---
          const player1Logo = players.find(p => p.player_id === g.player1_id)?.avatar || '';
          const player2Logo = players.find(p => p.player_id === g.player2_id)?.avatar || '';
          const player1Cell = `<td class="player-cell">
            <div style="display:flex; align-items:center; justify-content:center; gap:7px;">
              ${player1Logo ? `<img src="${player1Logo}" class="player-logo">` : ""}
              <a href="https://boardgamearena.com/player?id=${g.player1_id}" target="_blank">${g.player1}</a>
            </div>
          </td>`;
          const player2Cell = `<td class="player-cell">
            <div style="display:flex; align-items:center; justify-content:center; gap:7px;">
              <a href="https://boardgamearena.com/player?id=${g.player2_id}" target="_blank">${g.player2}</a>
              ${player2Logo ? `<img src="${player2Logo}" class="player-logo">` : ""}
            </div>
          </td>`;
          row.innerHTML = `
            <td class="date-cell">${g.time}</td>
            ${isGroupStage ? `<td>${g.group}</td>` : ""}
            ${player1Cell}
            <td class="score-cell">${g.score1} - ${g.score2}</td>
            ${player2Cell}
          `;
        }

        table.appendChild(row);
      });

      content.appendChild(table);
      section.appendChild(toggle);
      section.appendChild(content);
      container.appendChild(section);

      toggle.addEventListener("click", () => {
        const isOpen = toggle.classList.contains("open");

        if (openAccordion && openAccordion !== content) {
          openAccordion.style.maxHeight = "0px";
          openAccordion.previousElementSibling.classList.remove("open");
        }

        if (isOpen) {
          content.style.maxHeight = "0px";
          toggle.classList.remove("open");
          openAccordion = null;
        } else {
          content.style.maxHeight = content.scrollHeight + "px";
          toggle.classList.add("open");
          openAccordion = content;
        }
      });
    }
  }


  function renderPlayoffData(playoffMatches, containerOverride, tournamentType) {
    // --- RENDER PLAYOFF BRACKET ---
    // Build layout and UI for playoff bracket including match positions, labels, and connectors
    let container;
    let bracketDiv;
    if (containerOverride) {
      container = containerOverride;
      container.innerHTML = '';
      // Add a scrollable wrapper
      const scrollWrapper = document.createElement("div");
      scrollWrapper.className = "playoff-scroll-wrapper";
      // Add a wrapper for the bracket
      bracketDiv = document.createElement("div");
      bracketDiv.id = "playoff-bracket";
      scrollWrapper.appendChild(bracketDiv);
      container.appendChild(scrollWrapper);
      container = bracketDiv;
    } else {
      // fallback: legacy behavior
      container = document.getElementById("playoff-bracket");
      container.innerHTML = '';
    }
    
    const BRACKET_MARGIN = 15;
    const MATCH_HEIGHT = 60;
    const MATCH_WIDTH = 200;
    const ROUND_TITLE_TO_MATCH_SPACING = 35;
    const VERTICAL_SPACING = 20;
    const HORIZONTAL_SPACING = 30;
    const THIRD_PLACE_VERTICAL_OFFSET = 50;
    
    // Group matches by numeric round_order
    const groupedByRound = {};
    playoffMatches.forEach(match => {
      const roundNum = Number(match.round_order);
      if (!groupedByRound[roundNum]) groupedByRound[roundNum] = [];
      groupedByRound[roundNum].push(match);
    });
    
    // Sort rounds numerically ascending
    const sortedRounds = Object.keys(groupedByRound).map(Number).sort((a, b) => a - b);
    const roundIndexMap = {};
    sortedRounds.forEach((r, i) => roundIndexMap[r] = i);
    
    // 1. Find the round with the maximum number of matches
    const maxMatchRound = sortedRounds.reduce((maxRound, r) => {
      return (groupedByRound[r].length > groupedByRound[maxRound]?.length || !maxRound) ? r : maxRound;
    }, sortedRounds[0]);

    // 2. Layout matches of maxMatchRound
    groupedByRound[maxMatchRound]
      .filter(m => m.knockout_stage !== "third_place")
      .forEach((m, index) => {
        const cord_top = BRACKET_MARGIN+ ROUND_TITLE_TO_MATCH_SPACING + index * (MATCH_HEIGHT + VERTICAL_SPACING);
        const cord_left = BRACKET_MARGIN + roundIndexMap[maxMatchRound] * (MATCH_WIDTH + HORIZONTAL_SPACING);
        const cord_bottom = cord_top + MATCH_HEIGHT;
        m.cord_top = cord_top;
        m.cord_left = cord_left;
        m.cord_bottom = cord_bottom;
      });

    // 3. Layout rounds to the right of maxMatchRound
    for (let i = sortedRounds.indexOf(maxMatchRound) + 1; i < sortedRounds.length; i++) {
      const roundNum = sortedRounds[i];
      groupedByRound[roundNum]
        .filter(m => m.knockout_stage !== "third_place")
        .forEach(m => {
          const sources = sortedRounds[i - 1] ? groupedByRound[sortedRounds[i - 1]].filter(pm => pm.next_game_win === m.knockout_id) : [];
          let cord_top = 0;
          if (sources.length === 2) {
            const cord_top1 = groupedByRound[sortedRounds[i - 1]].find(pm => pm.knockout_id === sources[0].knockout_id).cord_top;
            const cord_top2 = groupedByRound[sortedRounds[i - 1]].find(pm => pm.knockout_id === sources[1].knockout_id).cord_top;
            const center = (cord_top1 + cord_top2 + MATCH_HEIGHT) / 2;
            cord_top = center - MATCH_HEIGHT / 2;
          } else if (sources.length === 1) {
            cord_top = groupedByRound[sortedRounds[i - 1]].find(pm => pm.knockout_id === sources[0].knockout_id).cord_top;
          }
          const cord_left = BRACKET_MARGIN + roundIndexMap[roundNum] * (MATCH_WIDTH + HORIZONTAL_SPACING);
          const cord_bottom = cord_top + MATCH_HEIGHT;
          m.cord_top = cord_top;
          m.cord_left = cord_left;
          m.cord_bottom = cord_bottom;
        });
    }

    // 4. Layout rounds to the left of maxMatchRound
    for (let i = sortedRounds.indexOf(maxMatchRound) - 1; i >= 0; i--) {
      const roundNum = sortedRounds[i];
      const nextRound = sortedRounds[i + 1];
      groupedByRound[nextRound]
        .filter(s => s.knockout_stage !== "third_place")
        .forEach(s => {
          const predecessors = groupedByRound[roundNum]?.filter(m => m.next_game_win === s.knockout_id) || [];
          if (predecessors.length === 1) {
            const cord_top = groupedByRound[nextRound].find(m => m.knockout_id === s.knockout_id).cord_top;
            const cord_left = BRACKET_MARGIN + roundIndexMap[roundNum] * (MATCH_WIDTH + HORIZONTAL_SPACING);
            const cord_bottom = cord_top + MATCH_HEIGHT;
            const match = groupedByRound[roundNum].find(m => m.knockout_id === predecessors[0].knockout_id);
            if (match) {
              match.cord_top = cord_top;
              match.cord_left = cord_left;
              match.cord_bottom = cord_bottom;
            }
          } else if (predecessors.length === 2) {
            const cord_topCenter = groupedByRound[nextRound].find(m => m.knockout_id === s.knockout_id).cord_top + MATCH_HEIGHT / 2;
            const cord_top1 = cord_topCenter - VERTICAL_SPACING / 2 - MATCH_HEIGHT;
            const cord_top2 = cord_topCenter + VERTICAL_SPACING / 2;
            const cord_left = BRACKET_MARGIN + roundIndexMap[roundNum] * (MATCH_WIDTH + HORIZONTAL_SPACING);
            const cord_bottom1 = cord_top1 + MATCH_HEIGHT;
            const cord_bottom2 = cord_top2 + MATCH_HEIGHT;
            const match1 = groupedByRound[roundNum].find(m => m.knockout_id === predecessors[0].knockout_id);
            const match2 = groupedByRound[roundNum].find(m => m.knockout_id === predecessors[1].knockout_id);
            if (match1) {
              match1.cord_top = cord_top1;
              match1.cord_left = cord_left;
              match1.cord_bottom = cord_bottom1;
            }
            if (match2) {
              match2.cord_top = cord_top2;
              match2.cord_left = cord_left;
              match2.cord_bottom = cord_bottom2;
            }
          }
        });
    }

    // 5. Add 3rd place match if exists
    const thirdPlaceMatch = playoffMatches.find(g => g.tournament_id === currentTournamentId && g.knockout_stage === "third_place");
    if (thirdPlaceMatch) {
      const thirdPlaceRound = Number(thirdPlaceMatch.round_order);
      const existingMatch = groupedByRound[thirdPlaceRound]?.find(m => m.knockout_id === thirdPlaceMatch.knockout_id);
      if (existingMatch) {
        let startTop = 0;
        const matchesInRound = groupedByRound[thirdPlaceRound].filter(m => m.knockout_id !== thirdPlaceMatch.knockout_id);
        if (matchesInRound.length > 0) {
          const lastMatch = matchesInRound[matchesInRound.length - 1];
          startTop = lastMatch.cord_bottom + THIRD_PLACE_VERTICAL_OFFSET;
        }
        existingMatch.cord_top = startTop;
        existingMatch.cord_left = BRACKET_MARGIN + roundIndexMap[thirdPlaceRound] * (MATCH_WIDTH + HORIZONTAL_SPACING);
        existingMatch.cord_bottom = startTop + ROUND_TITLE_TO_MATCH_SPACING + MATCH_HEIGHT;
        existingMatch.knockout_stage = "third_place";
      }
    }
    
    // Render matches with absolute positioning inside #playoff-bracket
    sortedRounds.forEach((roundNum, colIndex) => {
      const matches = groupedByRound[roundNum];
      matches.sort((a, b) => Number(a.game_id) - Number(b.game_id));

      // Додаємо назву раунду (label)
      const label = document.createElement("div");
      label.className = "round-label";
      label.textContent = matches.find(m => m.knockout_stage !== "third_place")?.round || `Round ${roundNum}`;
      label.style.position = "absolute";
      label.style.width = `${MATCH_WIDTH}px`;
      label.style.textAlign = "center";
      label.style.left = `${BRACKET_MARGIN + roundIndexMap[roundNum] * (MATCH_WIDTH + HORIZONTAL_SPACING)}px`;
      label.style.top = `${BRACKET_MARGIN}px`;
      container.appendChild(label);

      // Додаємо матчі
      matches.forEach((m) => {
        const matchBox = document.createElement("div");
        matchBox.className = "match-box";
        matchBox.style.width = `${MATCH_WIDTH}px`;
        matchBox.style.height = `${MATCH_HEIGHT}px`;
        matchBox.style.position = "absolute";

        let topOffset = m.cord_top;
        if (m.knockout_stage === "third_place") {
          // Назву раунду для матчу за 3-є місце додаємо окремо нижче
          const label = document.createElement("div");
          label.className = "round-label";
          label.style.position = "absolute";
          label.style.width = `${MATCH_WIDTH}px`;
          label.style.textAlign = "center";
          label.style.left = `${m.cord_left}px`;
          label.style.top = `${topOffset}px`;
          label.textContent = m.round || "3rd place";
          container.appendChild(label);
          topOffset += ROUND_TITLE_TO_MATCH_SPACING;
        }

        matchBox.style.top = `${topOffset}px`;
        matchBox.style.left = `${m.cord_left}px`;

        const opponent1Div = document.createElement("div");
        const opponent2Div = document.createElement("div");

        if (tournamentType === "TEAM") {
          // додаємо плейофф матчі з командами
          opponent1Div.className = m.duels_won1 > m.duels_won2 ? "match-row-winner" : "match-row-loser";
          // Team 1: logo + name
          let team1Logo = null;
          const team1Avatar = teams.find(tm => tm.team === m.team1)?.logo;
          if (team1Avatar) {
            team1Logo = document.createElement("img");
            team1Logo.src = team1Avatar;
            team1Logo.className = "team-logo";
          }
          const team1Info = document.createElement("div");
          team1Info.style.display = "flex";
          team1Info.style.alignItems = "center";
          if (team1Logo) team1Info.appendChild(team1Logo);
          const team1Name = document.createElement("span");
          team1Name.textContent = m.team1;
          team1Name.style.maxWidth = "150px";
          team1Name.style.display = "inline-block";
          team1Info.appendChild(team1Name);
          const score1Span = document.createElement("span");
          score1Span.textContent = m.duels_won1;
          opponent1Div.appendChild(team1Info);
          opponent1Div.appendChild(score1Span);
          // Add data-opponent-name attribute
          opponent1Div.setAttribute("data-opponent-name", m.team1);
          opponent2Div.className = m.duels_won1 < m.duels_won2 ? "match-row-winner" : "match-row-loser";
          // Team 2: logo + name
          let team2Logo = null;
          const team2Avatar = teams.find(tm => tm.team === m.team2)?.logo;
          if (team2Avatar) {
            team2Logo = document.createElement("img");
            team2Logo.src = team2Avatar;
            team2Logo.className = "team-logo";
          }
          const team2Info = document.createElement("div");
          team2Info.style.display = "flex";
          team2Info.style.alignItems = "center";
          if (team2Logo) team2Info.appendChild(team2Logo);
          const team2Name = document.createElement("span");
          team2Name.textContent = m.team2;
          team2Name.style.maxWidth = "150px";
          team2Name.style.display = "inline-block";
          team2Info.appendChild(team2Name);
          const score2Span = document.createElement("span");
          score2Span.textContent = m.duels_won2;
          opponent2Div.appendChild(team2Info);
          opponent2Div.appendChild(score2Span);
          // Add data-opponent-name attribute
          opponent2Div.setAttribute("data-opponent-name", m.team2);  
        } else {

          // додаємо плейофф матчі з гравцями
          opponent1Div.className = m.score1 > m.score2 ? "match-row-winner" : "match-row-loser";
          // Player 1: logo + link
          let player1Logo = null;
          const player1Avatar = players.find(pl => pl.player_id === m.player1_id)?.avatar;
          if (player1Avatar) {
            player1Logo = document.createElement("img");
            player1Logo.src = player1Avatar;
            player1Logo.className = "player-logo";
          }
          const player1Link = document.createElement("a");
          if (m.player1_id) {
            player1Link.href = `https://boardgamearena.com/player?id=${m.player1_id}`;
            player1Link.target = "_blank";
          } else {
            player1Link.removeAttribute("href");
          }
          player1Link.textContent = m.player1;
          // Add maxWidth and display for truncation
          player1Link.style.maxWidth = "150px";
          player1Link.style.display = "inline-block";
          const player1Info = document.createElement("div");
          player1Info.style.display = "flex";
          player1Info.style.alignItems = "center";
          if (player1Logo) player1Info.appendChild(player1Logo);
          player1Info.appendChild(player1Link);
          const score1Span = document.createElement("span");
          score1Span.textContent = m.score1;
          opponent1Div.appendChild(player1Info);
          opponent1Div.appendChild(score1Span);
          // Add data-opponent-name attribute
          opponent1Div.setAttribute("data-opponent-name", m.player1);
          
          opponent2Div.className = m.score1 < m.score2 ? "match-row-winner" : "match-row-loser";
          // Player 2: logo + link
          let player2Logo = null;
          const player2Avatar = players.find(pl => pl.player_id === m.player2_id)?.avatar;
          if (player2Avatar) {
            player2Logo = document.createElement("img");
            player2Logo.src = player2Avatar;
            player2Logo.className = "player-logo";
          }
          const player2Link = document.createElement("a");
          if (m.player2_id) {
            player2Link.href = `https://boardgamearena.com/player?id=${m.player2_id}`;
            player2Link.target = "_blank";
          } else {
            player2Link.removeAttribute("href");
          }
          player2Link.textContent = m.player2;
          // Add maxWidth and display for truncation
          player2Link.style.maxWidth = "150px";
          player2Link.style.display = "inline-block";
          const player2Info = document.createElement("div");
          player2Info.style.display = "flex";
          player2Info.style.alignItems = "center";
          if (player2Logo) player2Info.appendChild(player2Logo);
          player2Info.appendChild(player2Link);
          const score2Span = document.createElement("span");
          score2Span.textContent = m.score2;
          opponent2Div.appendChild(player2Info);
          opponent2Div.appendChild(score2Span);
          // Add data-opponent-name attribute
          opponent2Div.setAttribute("data-opponent-name", m.player2);  
        }

        matchBox.appendChild(opponent1Div);
        matchBox.appendChild(opponent2Div);
        container.appendChild(matchBox);
      });
    });
    
    // --- DRAW LINES ---
    // Build a map of knockout_id -> match for all matches
    const matchById = {};
    Object.values(groupedByRound).flat().forEach(m => {
      matchById[m.knockout_id] = m;
    });

    // Build playoffConnectors array
    const playoffConnectors = [];
    sortedRounds.forEach(roundNum => {
      groupedByRound[roundNum].forEach(match => {
        if (!match.next_game_win) return;
        const from = matchById[match.knockout_id];
        const to = matchById[match.next_game_win];
        if (!from || !to) return;

        const fromLeft = from.cord_left;
        const fromTop = from.cord_top;
        const toLeft = to.cord_left;
        const toTop = to.cord_top;

        const yFrom = fromTop + MATCH_HEIGHT / 2 - 1;
        const yTo = toTop + MATCH_HEIGHT / 2 - 1;
        const xFrom = fromLeft + MATCH_WIDTH;
        const xTo = toLeft;

        const connector = {
          game_from: match.knockout_id,
          game_to: match.next_game_win,
          lines: []
        };

        if (yFrom === yTo) {
          connector.lines.push({
            x1: xFrom,
            y1: yFrom,
            x2: xTo,
            y2: yTo
          });
        } else {
          const midX = fromLeft + MATCH_WIDTH + HORIZONTAL_SPACING / 2;
          const preX = toLeft - HORIZONTAL_SPACING / 2;
          const adjustedY2 = fromTop > toTop ? yTo + 5 : yTo - 5;

          connector.lines.push({
            x1: xFrom,
            y1: yFrom,
            x2: midX + 2,
            y2: yFrom
          });
          connector.lines.push({
            x1: midX,
            y1: yFrom,
            x2: midX,
            y2: adjustedY2
          });
          connector.lines.push({
            x1: preX + 3,
            y1: yTo,
            x2: xTo,
            y2: yTo
          });
        }

        playoffConnectors.push(connector);
      });
    });
    
    playoffConnectors.forEach(connector => {
      connector.lines.forEach(lineCoords => {
        const isHorizontal = lineCoords.y1 === lineCoords.y2;
        const lineDiv = document.createElement("div");
        lineDiv.style.position = "absolute";
        lineDiv.style.backgroundColor = "#ccc";
        lineDiv.style.zIndex = "0";

        if (isHorizontal) {
          lineDiv.style.left = `${lineCoords.x1}px`;
          lineDiv.style.top = `${lineCoords.y1}px`;
          lineDiv.style.width = `${lineCoords.x2 - lineCoords.x1}px`;
          lineDiv.style.height = "2px";
        } else {
          lineDiv.style.left = `${lineCoords.x1}px`;
          lineDiv.style.top = `${Math.min(lineCoords.y1, lineCoords.y2)}px`;
          lineDiv.style.width = "2px";
          lineDiv.style.height = `${Math.abs(lineCoords.y2 - lineCoords.y1)}px`;
        }

        container.appendChild(lineDiv);
      });
    });

    // Set container's fixed height based on the maximum cord_bottom plus BRACKET_MARGIN
    const allMatches = Object.values(groupedByRound).flat();
    const maxCordBottom = Math.max(...allMatches.map(m => m.cord_bottom || 0));
    container.style.height = `${maxCordBottom + BRACKET_MARGIN}px`;
    // Set container's fixed width based on the maximum cord_left plus MATCH_WIDTH + BRACKET_MARGIN
    const maxCordLeft = Math.max(...allMatches.map(m => m.cord_left || 0));
    container.style.width = `${maxCordLeft + MATCH_WIDTH + BRACKET_MARGIN}px`;

    // --- HOVER HIGHLIGHT LOGIC ---
    // After rendering all matches, add hover event for .match-row-winner and .match-row-loser
    const playoffContainer = container;
    playoffContainer.querySelectorAll(".match-row-winner, .match-row-loser").forEach(row => {
      const playerName = row.getAttribute("data-opponent-name");
      if (playerName !== "null") {
        row.addEventListener("mouseenter", () => {
          playoffContainer.querySelectorAll(`[data-opponent-name="${playerName}"]`).forEach(el => {
            el.classList.add("highlight-player");
          });
        });

        row.addEventListener("mouseleave", () => {
          playoffContainer.querySelectorAll(`[data-opponent-name="${playerName}"]`).forEach(el => {
            el.classList.remove("highlight-player");
          });
        });
      }
    });
  }

  document.addEventListener("DOMContentLoaded", () => {
    fetchTournamentsAndInit();
  });
</script>