<!-- ШРИФТ -->
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">

<!-- СТИЛІ -->
<style>
  body {
    font-family: 'Montserrat', sans-serif;
  }
  .tab-container {
    display: flex;
    gap: 0px;
    padding: 10px 0px;
  }

  .tab {
    padding: 6px 12px;
    font-size: 15px;
    font-weight: 600;
    color: #333333;
    background-color: transparent;
    border-radius: 0px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .tab.active,
  .tab:hover {
    background-color: #2C6DA3;
    color: white;
  }

  .group-section {
    margin: 5px 0;
    padding: 0 0px;
  }

  .group-title {
    font-size: 14px;
    font-weight: 700;
    margin-bottom: 3px;
    color: #222;
  }

  .overview-section-title {
    font-size: 17px;
    font-weight: 700;
    margin-bottom: 3px;
    color: #222;
  }

  .overview-about-text {
    font-size: 14px;
    color: #333;
  }

  .group-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 16px;
    border-radius: 2px;
    box-shadow: 1.4px 1.4px 2px #b2b2b2;
    overflow: hidden;
  }

  .group-table th {
    background-color: #2C6DA3;
    color: white;
    font-weight: 600;
    padding: 6px;
    font-size: 15px;
    text-align: center;
    width: auto;
    min-width: 40px;
  }

  .group-table td {
    padding: 6px;
    font-size: 15px;
    line-height: 17px;
    border-top: 1px solid #ccc;
    text-align: center;
  }

  .group-table tr:nth-child(n+2) {
    background-color: white;
  }

  .group-table td a {
    color: #333333;
    text-decoration: none;
    word-break: break-word;
  }

  .group-table td a:hover {
    color: #0277BD;
  }

  .match-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 5px;
    border-radius: 2px;
    box-shadow: 1.4px 1.4px 2px #b2b2b2;
    overflow: hidden;
  }

  .match-table th {
    background-color: #e0f0ff;
    padding: 6px;
    text-align: left;
    font-size: 15px;
  }

  .match-table td {
    background-color: white;
    padding: 6px;
    font-size: 15px;
    line-height: 17px;
    border-top: 1px solid #ccc;
  }
  .match-table td.date-cell {
    font-size: 13px;
    text-align: left;
    line-height: 15px;
  }
  .match-table td.player-cell {
    text-align: center;
  }
  .match-table td.score-cell {
    text-align: center;
    font-weight: 600;
    white-space: nowrap;
  }

  .match-table td a {
    color: #333333;
    text-decoration: none;
    word-break: break-word;
  }

  .match-table td a:hover {
    color: #0277BD;
  }

  .accordion-toggle {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: #2C6DA3;
    color: white;
    font-weight: 400;
    font-size: 15px;
    padding: 4px 10px;
    cursor: pointer;
    transition: background-color 0.2s ease;
    border-radius: 2px;
    box-shadow: 1.4px 1.4px 2px #b2b2b2;
  }

  .accordion-toggle:hover {
    background-color: #24598a;
  }

  .accordion-toggle .chevron {
    display: flex;
    align-items: center;
  }

  .accordion-toggle .chevron i {
    transition: transform 0.3s ease;
  }

  .accordion-toggle.open .chevron i {
    transform: rotate(180deg);
  }

  .accordion-content {
    overflow: hidden;
    transition: max-height 0.3s ease;
    padding: 0 2px;
  }

  #tab-playoff-content {
    display: block;
    overflow-x: auto;
    overflow-y: visible;
    height: auto !important;
    background-color: #f5f5f5;
  }
  #playoff-bracket {
    display: flex;
    align-items: flex-start;
    overflow-x: auto;
    width: 100%;
    position: relative;
    flex-wrap: nowrap;
    flex: 1 0 auto;
  }
  .round-label {
    font-weight: 600;
    font-size: 14px;
    margin-bottom: 10px;
  }
  .match-box {
    background-color: white;
    border: 1px solid #aaa;
    border-radius: 2px;
    font-size: 15px;
    line-height: 18px;
    margin-bottom: 20px;
    /*box-shadow: 1px 1px 2px #b2b2b2;*/
    box-sizing: border-box;
  }
  .match-box div {
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: 50%;
    gap: 6px;
  }
  .player-logo {
    height: 18px;
    width: 18px;
    border: 1px solid #000;
    object-fit: contain;
    margin-right: 0px;
    border-radius: 2px;
  }
  .match-box a {
    color: #333333;
    text-decoration: none;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .match-box a:hover {
    color: #0277BD;
  }

  .match-row-winner {
    /* background-color: #fff; */
    font-weight: 550;
    padding: 0 7px;  
  }

  .match-row-loser {
    /* background-color: #fff; */
    padding: 0 7px; 
  }

  .highlight-player {
    background-color: #eeeeee !important;
  }
</style>

<!-- HTML -->
<div id="tournament-title" style="font-size:18px; font-weight:700; line-height:20px; padding:0 0 10px;"></div>
<div class="tab-container">
  <div class="tab active" data-tab="overview">Overview</div>
  <div class="tab" data-tab="playoff">Playoff</div>
  <div class="tab" data-tab="standing">Standing</div>
  <div class="tab" data-tab="matches">Matches</div>
</div>
<div id="tab-overview-content" style="display:block;"></div>
<div id="tab-standing-content" style="display:block;"></div>
<div id="tab-matches-content" style="display:none;"></div>
<div id="tab-playoff-content" style="display:none;">
  <div id="playoff-bracket"></div>
</div>

<!-- СКРИПТ -->
<script>
  
  // --- TOURNAMENT ID ---
  // Determine currentTournamentId either from test default or from the page URL
  const useTestData = window.location.hostname !== "carcassonne.gg";
  let currentTournamentId = useTestData
    ? "UCOC-2025"
    : window.location.pathname.split('/').filter(Boolean).pop();
  let currentTournament = null;

  function fetchTournamentsAndInit() {
    // --- FETCH TOURNAMENTS ---
    // Load tournament metadata and initialize tournament display
    if (useTestData) {
      const allTournaments = [
       {"about":"<p><strong>Ukrainian Carcassonne Online Championship (UCOC) 2025</strong> is a national tournament in which we play on the Board Game Arena (BGA) platform, in weekly one-on-one matches in the Best of Three format.</p><p>Each season takes place once a year, organized by player divisions with promotion and relegation. Only Ukrainian players are admitted to the championship.</p><p><strong>Dates:</strong> January 20 - April 6, 2025</p><p>In addition to enjoying the competition and the community built around Carcassonne, the winner of the top division of UCOC 2025 will get the chance to represent Ukraine in the Carcassonne Champions League 2026.</p><p>The tournament was recognized as the official Online Carcassonne Championship of Ukraine by Feelindigo, the publisher of the game in Ukraine.</p>","country":"Ukraine","end_date":"6/4/25","external_link":"","final_ranking":"1,bazilyuk,\ud83e\udd47;2,pavelbrin,\ud83e\udd48;3,Lawyer,\ud83e\udd49","flag":"https://carcassonne.gg/gallery/ukraine.png","format":[],"groups":"","name":"Ukrainian Carcassonne Online Championship 2025. Super League","playoffs":[],"start_date":"20/1/25","status":"Done","title":"2025 - Championship","tournament_id":"UCOC-2025","type":"Round-robin"}
      ];
      currentTournament = allTournaments.find(t => t.tournament_id === currentTournamentId);
      if (currentTournament) {
        document.getElementById("tournament-title").textContent = currentTournament.name;
      }
      fetchGamesAndStandings();
    } else {
      fetch("https://api.carcassonne.com.ua/coc_tournaments")
        .then(res => res.json())
        .then(data => {
          const allTournaments = data.coc_tournaments;
          currentTournament = allTournaments.find(t => t.tournament_id === currentTournamentId);
          if (currentTournament) {
            document.getElementById("tournament-title").textContent = currentTournament.name;
          }
          fetchGamesAndStandings();
        });
    }
  }

  let games = [];
  let standings = [];

  function fetchGamesAndStandings() {
    // --- FETCH GAMES AND STANDINGS ---
    // Load games and standings data for the selected tournament (test or real)
    if (useTestData) {
      games = [
        {"format":"Bo3","game_id":"","group":"","knockout_stage":"","next_game_loss":"","next_game_win":"","player1":"zaharik","player1_id":"84375106","player1_logo":"https://x.boardgamearena.net/data/avatar/0/84/84375/84375106_184.jpg","player2":"Spitki","player2_id":"94099302","player2_logo":"https://x.boardgamearena.net/data/avatar/defaults/default-2374.jpg","result1":"1","result2":"0","round":"Round 1","round_order":"","score1":"2","score2":"1","stage":"Round-robin","status":"DONE","time":"22.01 22:00","tournament_id":"UCOC-2025","type":""}
      ];
      standings = [
        {"games_difference":"2","games_lost":"13","games_won":"15","group":"","matches_difference":"1","matches_lost":"5","matches_played":"11","matches_won":"6","player":"zaharik","player_id":"84375106","player_logo":"https://x.boardgamearena.net/data/avatar/0/84/84375/84375106_184.jpg","tournament_id":"UCOC-2025"}
      ];
    } else {
      const gamesPromise = fetch("https://api.carcassonne.com.ua/coc_games").then(res => res.json());
      const standingsPromise = fetch("https://api.carcassonne.com.ua/coc_standings").then(res => res.json());
      Promise.all([gamesPromise, standingsPromise])
        .then(([gamesData, standingsData]) => {
          games = gamesData.coc_games;
          standings = standingsData.coc_standings;
          initAndRenderTournamentContent(currentTournament);
        });
    }

    if (useTestData) {
      initAndRenderTournamentContent(currentTournament);
    }
  }

  function initAndRenderTournamentContent(currentTournament) {
    // --- INIT TOURNAMENT CONTENT ---
    // Determine which tabs and render functions to activate based on tournament type
    const tabContainer = document.querySelector(".tab-container");
    if (!currentTournament) {
      tabContainer.style.display = "none";
      document.getElementById("tab-standing-content").textContent = "No tournament found with appropriate ID";
      return;
    }

    // Always show overview tab
    document.querySelector('[data-tab="overview"]').style.display = "block";

    const type = currentTournament.type;
    const tabs = document.querySelectorAll(".tab");
    tabs.forEach(tab => {
      if (tab.dataset.tab !== "overview") {
        tab.style.display = "none";
      }
    });

    if (type === "Group Stage + Playoff") {
      tabs.forEach(tab => tab.style.display = "block");
    } else if (type === "Single Elimination") {
      document.querySelector('[data-tab="matches"]').style.display = "block";
      document.querySelector('[data-tab="playoff"]').style.display = "block";
      showTab("matches");
    } else if (type === "Round-robin") {
      document.querySelector('[data-tab="standing"]').style.display = "block";
      document.querySelector('[data-tab="matches"]').style.display = "block";
    }

    // Render Overview content (new function)
    renderOverviewContent();

    if (type.includes("Round-robin") || type.includes("Group Stage")) {
      renderStandingsData({ coc_standings: standings });
    }
    renderMatchesData({ coc_games: games });
    if (type.includes("Group Stage + Playoff") || type.includes("Single Elimination")) {
      renderPlayoffData({ coc_games: games });
    }
  }

  function renderOverviewContent() {
    const container = document.getElementById("tab-overview-content");
    container.innerHTML = '';

    if (currentTournament.final_ranking) {
      const section = document.createElement("div");
      section.className = "group-section";

      const title = document.createElement("div");
      title.className = "overview-section-title";
      title.textContent = "Final Ranking";
      section.appendChild(title);

      const table = document.createElement("table");
      // Apply special styling for Final Ranking table only
      table.className = "group-table";
      table.style.maxWidth = "400px";
      table.style.margin = "0 auto";

      table.innerHTML = `
        <tr>
          <th style="width:10%; min-width:40px;">Rank</th>
          <th style="width:90%; min-width:100px; text-align:left;">Player</th>
        </tr>
      `;

      const entries = currentTournament.final_ranking.split(';').map(entry => {
        const [order, player, icon] = entry.split(',');
        return { order: parseInt(order), player, icon };
      });

      entries.sort((a, b) => a.order - b.order).forEach(entry => {
        const row = document.createElement("tr");
        row.innerHTML = `
          <td style="text-align:center;">${entry.icon}</td>
          <td style="text-align:left;">${entry.player}</td>
        `;
        table.appendChild(row);
      });

      section.appendChild(table);
      container.appendChild(section);
    }

    if (currentTournament.about) {
      const section = document.createElement("div");
      section.className = "group-section";

      const title = document.createElement("div");
      title.className = "overview-section-title";
      title.textContent = "About";
      section.appendChild(title);

      const content = document.createElement("div");
      content.innerHTML = currentTournament.about;
      content.className = "overview-about-text";
      section.appendChild(content);
      container.appendChild(section);
    }
  }

  function showTab(tab) {
    // --- TOGGLE TABS ---
    // Handle switching between Standing, Matches, Playoff, and Overview views
    document.querySelectorAll(".tab").forEach(el => {
      el.classList.toggle("active", el.dataset.tab === tab);
    });
    document.getElementById("tab-overview-content").style.display = tab === "overview" ? "block" : "none";
    document.getElementById("tab-standing-content").style.display = tab === "standing" ? "block" : "none";
    document.getElementById("tab-matches-content").style.display = tab === "matches" ? "block" : "none";
    document.getElementById("tab-playoff-content").style.display = tab === "playoff" ? "block" : "none";
  }

  function renderStandingsData(data) {
    // --- RENDER STANDINGS ---
    // Build standings tables grouped by group, sorted and styled with logos
    const container = document.getElementById("tab-standing-content");
    container.innerHTML = '';
    const grouped = {};

    data.coc_standings
      .filter(row => row.tournament_id === currentTournamentId)
      .forEach(row => {
        if (!grouped[row.group]) grouped[row.group] = [];
        grouped[row.group].push(row);
      });

    for (const [group, players] of Object.entries(grouped)) {
      const section = document.createElement("div");
      section.className = "group-section";

      const title = document.createElement("div");
      title.className = "group-title";
      title.textContent = `Group ${group}`;
      section.appendChild(title);

      players.sort((a, b) => {
        const mwDiff = +b.matches_won - +a.matches_won;
        if (mwDiff !== 0) return mwDiff;
        const mdDiff = +b.matches_difference - +a.matches_difference;
        if (mdDiff !== 0) return mdDiff;
        return +b.games_difference - +a.games_difference;
      });

      const table = document.createElement("table");
      table.className = "group-table";

      table.innerHTML = `
        <tr>
          <th style="width:5%; min-width:30px;"></th>
          <th style="width:45%; min-width:150px; text-align:left;">Player</th>
          <th style="width:10%; min-width:30px;">MP</th>
          <th style="width:10%; min-width:30px;">MW</th>
          <th style="width:10%; min-width:30px;">ML</th>
          <th style="width:10%; min-width:30px;">GW</th>
          <th style="width:10%; min-width:30px;">GL</th>
        </tr>
      `;

      players.forEach((p, index) => {
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${index + 1}</td>
          <td style="text-align:left;">
            <div style="display: flex; align-items: center; gap: 7px;">
              ${p.player_logo ? `<img src="${p.player_logo}" class="player-logo">` : ''}
              <a href="https://boardgamearena.com/player?id=${p.player_id}" target="_blank" style="display: inline-block; white-space: normal; word-break: break-word;">${p.player}</a>
            </div>
          </td>
          <td>${p.matches_played}</td>
          <td>${p.matches_won}</td>
          <td>${p.matches_lost}</td>
          <td>${p.games_won}</td>
          <td>${p.games_lost}</td>
        `;
        table.appendChild(row);
      });

      section.appendChild(table);
      container.appendChild(section);
    }

    const explanation = document.createElement("div");
    explanation.style.fontSize = "13px";
    explanation.innerHTML = "MP: Matches Played MW: Matches Won ML: Matches Lost GW: Games Won GL: Games Lost<br><br>The final positions in the group will be determined in the following order:<br>1. Number of MW<br>2. The difference between GW and GL<br>3. Number of GW<br>4. Tiebreakers 1-3, but applied only to confrontations between players with equal results<br>5. The difference in points scored in confrontations between players with equal results<br>6. Random draw";
    container.appendChild(explanation);
  }

  function renderMatchesData(data) {
    // --- RENDER MATCHES ---
    // Group matches by round and build collapsible sections for each round
    const container = document.getElementById("tab-matches-content");
    container.innerHTML = '';

    const grouped = {};
    data.coc_games
      .filter(game => game.tournament_id === currentTournamentId)
      .forEach(game => {
        if (!grouped[game.round]) grouped[game.round] = [];
        grouped[game.round].push(game);
      });

    let openAccordion = null;

    for (const [round, games] of Object.entries(grouped)) {
      const section = document.createElement("div");
      section.className = "group-section";

      const toggle = document.createElement("div");
      toggle.className = "accordion-toggle";
      toggle.innerHTML = '';
      const labelSpan = document.createElement("span");
      labelSpan.textContent = round;

      const chevronDiv = document.createElement("div");
      chevronDiv.className = "chevron";
      chevronDiv.innerHTML = '<i class="fas fa-chevron-down"></i>';

      toggle.appendChild(labelSpan);
      toggle.appendChild(chevronDiv);

      const content = document.createElement("div");
      content.className = "accordion-content";
      content.style.maxHeight = "0px";

      const table = document.createElement("table");
      table.className = "match-table";

      const isGroupStage = games[0]?.stage === "Group";

      games.forEach(g => {
        const row = document.createElement("tr");
        row.innerHTML = `
          <td class="date-cell">${g.time}</td>
          ${isGroupStage ? `<td>${g.group}</td>` : ""}
          <td class="player-cell"><a href="https://boardgamearena.com/player?id=${g.player1_id}" target="_blank">${g.player1}</a></td>
          <td class="score-cell">${g.score1} - ${g.score2}</td>
          <td class="player-cell"><a href="https://boardgamearena.com/player?id=${g.player2_id}" target="_blank">${g.player2}</a></td>
        `;
        table.appendChild(row);
      });

      content.appendChild(table);
      section.appendChild(toggle);
      section.appendChild(content);
      container.appendChild(section);

      toggle.addEventListener("click", () => {
        const isOpen = toggle.classList.contains("open");

        if (openAccordion && openAccordion !== content) {
          openAccordion.style.maxHeight = "0px";
          openAccordion.previousElementSibling.classList.remove("open");
        }

        if (isOpen) {
          content.style.maxHeight = "0px";
          toggle.classList.remove("open");
          openAccordion = null;
        } else {
          content.style.maxHeight = content.scrollHeight + "px";
          toggle.classList.add("open");
          openAccordion = content;
        }
      });
    }
  }


  function renderPlayoffData(data) {
    // --- RENDER PLAYOFF BRACKET ---
    // Build layout and UI for playoff bracket including match positions, labels, and connectors
    const container = document.getElementById("playoff-bracket");
    container.innerHTML = '';

    const BRACKET_MARGIN = 15;
    const MATCH_HEIGHT = 60;
    const MATCH_WIDTH = 200;
    const ROUND_TITLE_TO_MATCH_SPACING = 35;
    const VERTICAL_SPACING = 20;
    const HORIZONTAL_SPACING = 30;
    const THIRD_PLACE_VERTICAL_OFFSET = 50;

    // Filter playoff matches with round_order defined, tournament_id matches, stage is "Playoff", and not "third_place"
    const playoffMatches = data.coc_games.filter(game =>
      game.tournament_id === currentTournamentId &&
      game.stage === "Playoff" &&
      game.round_order !== undefined &&
      game.round_order !== null
    );

    // Group matches by numeric round_order
    const groupedByRound = {};
    playoffMatches.forEach(match => {
      const roundNum = Number(match.round_order);
      if (!groupedByRound[roundNum]) groupedByRound[roundNum] = [];
      groupedByRound[roundNum].push(match);
    });

    // Sort rounds numerically ascending
    const sortedRounds = Object.keys(groupedByRound).map(Number).sort((a, b) => a - b);
    const roundIndexMap = {};
    sortedRounds.forEach((r, i) => roundIndexMap[r] = i);

    // 1. Find the round with the maximum number of matches
    const maxMatchRound = sortedRounds.reduce((maxRound, r) => {
      return (groupedByRound[r].length > groupedByRound[maxRound]?.length || !maxRound) ? r : maxRound;
    }, sortedRounds[0]);

    // 2. Layout matches of maxMatchRound
    groupedByRound[maxMatchRound]
      .filter(m => m.knockout_stage !== "third_place")
      .forEach((m, index) => {
        const cord_top = BRACKET_MARGIN+ ROUND_TITLE_TO_MATCH_SPACING + index * (MATCH_HEIGHT + VERTICAL_SPACING);
        const cord_left = BRACKET_MARGIN + roundIndexMap[maxMatchRound] * (MATCH_WIDTH + HORIZONTAL_SPACING);
        const cord_bottom = cord_top + MATCH_HEIGHT;
        m.cord_top = cord_top;
        m.cord_left = cord_left;
        m.cord_bottom = cord_bottom;
      });

    // 3. Layout rounds to the right of maxMatchRound
    for (let i = sortedRounds.indexOf(maxMatchRound) + 1; i < sortedRounds.length; i++) {
      const roundNum = sortedRounds[i];
      groupedByRound[roundNum]
        .filter(m => m.knockout_stage !== "third_place")
        .forEach(m => {
          const sources = sortedRounds[i - 1] ? groupedByRound[sortedRounds[i - 1]].filter(pm => pm.next_game_win === m.game_id) : [];
          let cord_top = 0;
          if (sources.length === 2) {
            const cord_top1 = groupedByRound[sortedRounds[i - 1]].find(pm => pm.game_id === sources[0].game_id).cord_top;
            const cord_top2 = groupedByRound[sortedRounds[i - 1]].find(pm => pm.game_id === sources[1].game_id).cord_top;
            const center = (cord_top1 + cord_top2 + MATCH_HEIGHT) / 2;
            cord_top = center - MATCH_HEIGHT / 2;
          } else if (sources.length === 1) {
            cord_top = groupedByRound[sortedRounds[i - 1]].find(pm => pm.game_id === sources[0].game_id).cord_top;
          }
          const cord_left = BRACKET_MARGIN + roundIndexMap[roundNum] * (MATCH_WIDTH + HORIZONTAL_SPACING);
          const cord_bottom = cord_top + MATCH_HEIGHT;
          m.cord_top = cord_top;
          m.cord_left = cord_left;
          m.cord_bottom = cord_bottom;
        });
    }

    // 4. Layout rounds to the left of maxMatchRound
    for (let i = sortedRounds.indexOf(maxMatchRound) - 1; i >= 0; i--) {
      const roundNum = sortedRounds[i];
      const nextRound = sortedRounds[i + 1];
      groupedByRound[nextRound]
        .filter(s => s.knockout_stage !== "third_place")
        .forEach(s => {
          const predecessors = groupedByRound[roundNum]?.filter(m => m.next_game_win === s.game_id) || [];
          if (predecessors.length === 1) {
            const cord_top = groupedByRound[nextRound].find(m => m.game_id === s.game_id).cord_top;
            const cord_left = BRACKET_MARGIN + roundIndexMap[roundNum] * (MATCH_WIDTH + HORIZONTAL_SPACING);
            const cord_bottom = cord_top + MATCH_HEIGHT;
            const match = groupedByRound[roundNum].find(m => m.game_id === predecessors[0].game_id);
            if (match) {
              match.cord_top = cord_top;
              match.cord_left = cord_left;
              match.cord_bottom = cord_bottom;
            }
          } else if (predecessors.length === 2) {
            const cord_topCenter = groupedByRound[nextRound].find(m => m.game_id === s.game_id).cord_top + MATCH_HEIGHT / 2;
            const cord_top1 = cord_topCenter - VERTICAL_SPACING / 2 - MATCH_HEIGHT;
            const cord_top2 = cord_topCenter + VERTICAL_SPACING / 2;
            const cord_left = BRACKET_MARGIN + roundIndexMap[roundNum] * (MATCH_WIDTH + HORIZONTAL_SPACING);
            const cord_bottom1 = cord_top1 + MATCH_HEIGHT;
            const cord_bottom2 = cord_top2 + MATCH_HEIGHT;
            const match1 = groupedByRound[roundNum].find(m => m.game_id === predecessors[0].game_id);
            const match2 = groupedByRound[roundNum].find(m => m.game_id === predecessors[1].game_id);
            if (match1) {
              match1.cord_top = cord_top1;
              match1.cord_left = cord_left;
              match1.cord_bottom = cord_bottom1;
            }
            if (match2) {
              match2.cord_top = cord_top2;
              match2.cord_left = cord_left;
              match2.cord_bottom = cord_bottom2;
            }
          }
        });
    }

    // 5. Add 3rd place match if exists
    const thirdPlaceMatch = data.coc_games.find(g => g.tournament_id === currentTournamentId && g.knockout_stage === "third_place");
    if (thirdPlaceMatch) {
      const thirdPlaceRound = Number(thirdPlaceMatch.round_order);
      const existingMatch = groupedByRound[thirdPlaceRound]?.find(m => m.game_id === thirdPlaceMatch.game_id);
      if (existingMatch) {
        let startTop = 0;
        const matchesInRound = groupedByRound[thirdPlaceRound].filter(m => m.game_id !== thirdPlaceMatch.game_id);
        if (matchesInRound.length > 0) {
          const lastMatch = matchesInRound[matchesInRound.length - 1];
          startTop = lastMatch.cord_bottom + THIRD_PLACE_VERTICAL_OFFSET;
        }
        existingMatch.cord_top = startTop;
        existingMatch.cord_left = BRACKET_MARGIN + roundIndexMap[thirdPlaceRound] * (MATCH_WIDTH + HORIZONTAL_SPACING);
        existingMatch.cord_bottom = startTop + ROUND_TITLE_TO_MATCH_SPACING + MATCH_HEIGHT;
        existingMatch.knockout_stage = "third_place";
      }
    }
    
    // Render matches with absolute positioning inside #playoff-bracket
    sortedRounds.forEach((roundNum, colIndex) => {
      const matches = groupedByRound[roundNum];
      matches.sort((a, b) => Number(a.game_id) - Number(b.game_id));

      // Додаємо назву раунду (label)
      const label = document.createElement("div");
      label.className = "round-label";
      label.textContent = matches.find(m => m.knockout_stage !== "third_place")?.round || `Round ${roundNum}`;
      label.style.position = "absolute";
      label.style.width = `${MATCH_WIDTH}px`;
      label.style.textAlign = "center";
      label.style.left = `${BRACKET_MARGIN + roundIndexMap[roundNum] * (MATCH_WIDTH + HORIZONTAL_SPACING)}px`;
      label.style.top = `${BRACKET_MARGIN}px`;
      container.appendChild(label);

      // Додаємо матчі
      matches.forEach((m) => {
        const matchBox = document.createElement("div");
        matchBox.className = "match-box";
        matchBox.style.width = `${MATCH_WIDTH}px`;
        matchBox.style.height = `${MATCH_HEIGHT}px`;
        matchBox.style.position = "absolute";

        let topOffset = m.cord_top;
        if (m.knockout_stage === "third_place") {
          // Назву раунду для матчу за 3-є місце додаємо окремо нижче
          const label = document.createElement("div");
          label.className = "round-label";
          label.style.position = "absolute";
          label.style.width = `${MATCH_WIDTH}px`;
          label.style.textAlign = "center";
          label.style.left = `${m.cord_left}px`;
          label.style.top = `${topOffset}px`;
          label.textContent = m.round || "3rd place";
          container.appendChild(label);
          topOffset += ROUND_TITLE_TO_MATCH_SPACING;
        }

        matchBox.style.top = `${topOffset}px`;
        matchBox.style.left = `${m.cord_left}px`;

        // (залишається існуючий код додавання player1Div, player2Div)
        const player1Div = document.createElement("div");
        player1Div.className = m.result1 === "1" ? "match-row-winner" : "match-row-loser";
        // Player 1: logo + link
        let player1Logo = null;
        if (m.player1_logo) {
          player1Logo = document.createElement("img");
          player1Logo.src = m.player1_logo;
          player1Logo.className = "player-logo";
        }
        const player1Link = document.createElement("a");
        if (m.player1_id) {
          player1Link.href = `https://boardgamearena.com/player?id=${m.player1_id}`;
          player1Link.target = "_blank";
        } else {
          player1Link.removeAttribute("href");
        }
        player1Link.textContent = m.player1;
        // Add maxWidth and display for truncation
        player1Link.style.maxWidth = "150px";
        player1Link.style.display = "inline-block";
        const player1Info = document.createElement("div");
        player1Info.style.display = "flex";
        player1Info.style.alignItems = "center";
        if (player1Logo) player1Info.appendChild(player1Logo);
        player1Info.appendChild(player1Link);
        const score1Span = document.createElement("span");
        score1Span.textContent = m.score1;
        player1Div.appendChild(player1Info);
        player1Div.appendChild(score1Span);
        // Add data-player-name attribute
        player1Div.setAttribute("data-player-name", m.player1);

        const player2Div = document.createElement("div");
        player2Div.className = m.result2 === "1" ? "match-row-winner" : "match-row-loser";
        // Player 2: logo + link
        let player2Logo = null;
        if (m.player2_logo) {
          player2Logo = document.createElement("img");
          player2Logo.src = m.player2_logo;
          player2Logo.className = "player-logo";
        }
        const player2Link = document.createElement("a");
        if (m.player2_id) {
          player2Link.href = `https://boardgamearena.com/player?id=${m.player2_id}`;
          player2Link.target = "_blank";
        } else {
          player2Link.removeAttribute("href");
        }
        player2Link.textContent = m.player2;
        // Add maxWidth and display for truncation
        player2Link.style.maxWidth = "150px";
        player2Link.style.display = "inline-block";
        const player2Info = document.createElement("div");
        player2Info.style.display = "flex";
        player2Info.style.alignItems = "center";
        if (player2Logo) player2Info.appendChild(player2Logo);
        player2Info.appendChild(player2Link);
        const score2Span = document.createElement("span");
        score2Span.textContent = m.score2;
        player2Div.appendChild(player2Info);
        player2Div.appendChild(score2Span);
        // Add data-player-name attribute
        player2Div.setAttribute("data-player-name", m.player2);

        matchBox.appendChild(player1Div);
        matchBox.appendChild(player2Div);
        container.appendChild(matchBox);
      });
    });
    
    // --- DRAW LINES ---
    // Build a map of game_id -> match for all matches
    const matchById = {};
    Object.values(groupedByRound).flat().forEach(m => {
      matchById[m.game_id] = m;
    });

    // Build playoffConnectors array
    const playoffConnectors = [];
    sortedRounds.forEach(roundNum => {
      groupedByRound[roundNum].forEach(match => {
        if (!match.next_game_win) return;
        const from = matchById[match.game_id];
        const to = matchById[match.next_game_win];
        if (!from || !to) return;

        const fromLeft = from.cord_left;
        const fromTop = from.cord_top;
        const toLeft = to.cord_left;
        const toTop = to.cord_top;

        const yFrom = fromTop + MATCH_HEIGHT / 2 - 1;
        const yTo = toTop + MATCH_HEIGHT / 2 - 1;
        const xFrom = fromLeft + MATCH_WIDTH;
        const xTo = toLeft;

        const connector = {
          game_from: match.game_id,
          game_to: match.next_game_win,
          lines: []
        };

        if (yFrom === yTo) {
          connector.lines.push({
            x1: xFrom,
            y1: yFrom,
            x2: xTo,
            y2: yTo
          });
        } else {
          const midX = fromLeft + MATCH_WIDTH + HORIZONTAL_SPACING / 2;
          const preX = toLeft - HORIZONTAL_SPACING / 2;
          const adjustedY2 = fromTop > toTop ? yTo + 5 : yTo - 5;

          connector.lines.push({
            x1: xFrom,
            y1: yFrom,
            x2: midX + 2,
            y2: yFrom
          });
          connector.lines.push({
            x1: midX,
            y1: yFrom,
            x2: midX,
            y2: adjustedY2
          });
          connector.lines.push({
            x1: preX + 3,
            y1: yTo,
            x2: xTo,
            y2: yTo
          });
        }

        playoffConnectors.push(connector);
      });
    });
    
    playoffConnectors.forEach(connector => {
      connector.lines.forEach(lineCoords => {
        const isHorizontal = lineCoords.y1 === lineCoords.y2;
        const lineDiv = document.createElement("div");
        lineDiv.style.position = "absolute";
        lineDiv.style.backgroundColor = "#ccc";
        lineDiv.style.zIndex = "0";

        if (isHorizontal) {
          lineDiv.style.left = `${lineCoords.x1}px`;
          lineDiv.style.top = `${lineCoords.y1}px`;
          lineDiv.style.width = `${lineCoords.x2 - lineCoords.x1}px`;
          lineDiv.style.height = "2px";
        } else {
          lineDiv.style.left = `${lineCoords.x1}px`;
          lineDiv.style.top = `${Math.min(lineCoords.y1, lineCoords.y2)}px`;
          lineDiv.style.width = "2px";
          lineDiv.style.height = `${Math.abs(lineCoords.y2 - lineCoords.y1)}px`;
        }

        container.appendChild(lineDiv);
      });
    });

    // Set container's fixed height based on the maximum cord_bottom plus BRACKET_MARGIN
    const allMatches = Object.values(groupedByRound).flat();
    const maxCordBottom = Math.max(...allMatches.map(m => m.cord_bottom || 0));
    container.style.height = `${maxCordBottom + BRACKET_MARGIN}px`;
    // Set container's fixed width based on the maximum cord_left plus MATCH_WIDTH + BRACKET_MARGIN
    const maxCordLeft = Math.max(...allMatches.map(m => m.cord_left || 0));
    container.style.width = `${maxCordLeft + MATCH_WIDTH + BRACKET_MARGIN}px`;

    // --- HOVER HIGHLIGHT LOGIC ---
    // After rendering all matches, add hover event for .match-row-winner and .match-row-loser
    const playoffContainer = document.getElementById("playoff-bracket");
    playoffContainer.querySelectorAll(".match-row-winner, .match-row-loser").forEach(row => {
      const playerName = row.getAttribute("data-player-name");
      if (playerName !== "null") {
        row.addEventListener("mouseenter", () => {
          playoffContainer.querySelectorAll(`[data-player-name="${playerName}"]`).forEach(el => {
            el.classList.add("highlight-player");
          });
        });

        row.addEventListener("mouseleave", () => {
          playoffContainer.querySelectorAll(`[data-player-name="${playerName}"]`).forEach(el => {
            el.classList.remove("highlight-player");
          });
        });
      }
    });
  }

  document.addEventListener("DOMContentLoaded", () => {
    fetchTournamentsAndInit();
    showTab("overview");
    //useTestData ? showTab("playoff") : showTab("overview")
    document.querySelectorAll(".tab").forEach(tabEl => {
      tabEl.addEventListener("click", () => {
        showTab(tabEl.dataset.tab);
      });
    });
  });
</script>
